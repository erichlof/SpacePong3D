<!DOCTYPE html>
<html>

<head>
	<meta name="viewport" content="width=device-width, height=device-height, user-scalable=no">
	<title>SpacePong3D</title>
</head>

<body>
	<div id="gametitle" style="position:fixed; left:2%; top:4%; font-family:arial; font-type:bold; color:lightgrey;">
		SpacePong3D
	</div>
	
	<div id="gravity" style="position:fixed; left:2%; top:8%; font-family:arial; color:rgb(100,100,100); border:thin solid;">
		Gravity OFF
	</div>
	
	<div id="difficulty" style="position:fixed; left:2%; top:13%; font-family:arial; color:rgb(100,100,100); border:thin solid;">
		Difficulty: MEDIUM
	</div>

	<div id="help1" style="position:fixed; left:2%; bottom:8%; font-family:arial; font-size:11px; color:lightgrey;">
		Desktop: Press 'M' to control paddle with Mouse
	</div>

	<div id="help2" style="position:fixed; left:2%; bottom:4%; font-family:arial; font-size:11px; color:lightgrey;">
		Mobile: slow Swipe to control paddle
	</div>
	
	<div id="bluescore" style="position:fixed; right:18%; top:4%; font-family:arial; font-type:bold; color:blue;">
		0
	</div>
	
	<div id="redscore" style="position:fixed; right:3%; top:4%; font-family:arial; font-type:bold; color:red;">
		0
	</div>
	
	<div id="winner" style="position:fixed; left:40%; top:20%; font-family:arial; font-type:bold; color:black;">
	
	</div>
	
	
	<script src="http://threejs.org/build/three.min.js"></script>
	<script src="js/threex.texturecube.js"></script>
	<script src="js/threex.skymap.js"></script>
	<script src="js/threex.keyboardstate.js"></script>
	<script src="js/virtualjoystick.js"></script>
	<script src="js/threex.GameTimer.js"></script>
	<script src="js/threex.geometricglowmesh.js"></script>
	<script src="js/webaudioxGameSounds.js"></script>
	
	<script>
		var windowWidth = window.innerWidth;
		var windowHeight = window.innerHeight;
		var halfWindowWidth = windowWidth / 2;
		var halfWindowHeight = windowHeight / 2;
		var scene = new THREE.Scene();
		var camera = new THREE.PerspectiveCamera( 65, windowWidth / windowHeight, 0.1, 2000 );
		var clock = new THREE.Clock();
		var missedTimer = new THREEx.GameTimer( 3 );
		var cutSceneTimer = new THREEx.GameTimer( 6 );
		var keyboard = new THREEx.KeyboardState();
		var joystick = new VirtualJoystick({
			mouseSupport: true,
			hideJoystick: true
		});

		var renderer = new THREE.WebGLRenderer({ antialias:true });
		renderer.setClearColor( 'rgb(0,0,0)', 1 );
		renderer.setSize( windowWidth, windowHeight );
		document.body.appendChild( renderer.domElement );
		window.addEventListener( 'resize', onWindowResize, false );

		var gameReset = true;
		var frameTime = 0;
		var firstTouchMove = true;
		var joystickDampening = 2;
		var deltaXDifference = 0;
		var deltaYDifference = 0;
		var oldDeltaX = 0;
		var oldDeltaY = 0;
		var newDeltaX = 0;
		var newDeltaY = 0;

		var ballSpeed = 0;
		var ballDirection = new THREE.Vector3( 0, 0, 0 );
		var gravityOn = false;
		var ballRadius = 3;
		var paddleWidth = 20;
		var paddleHeight = 14;
		var paddleDepth = 4;
		var halfPaddleWidth = paddleWidth / 2;
		var halfPaddleHeight = paddleHeight / 2;
		var arenaWidth = 100; //100
		var arenaHeight = 60; //60
		var arenaDepth = 200; //200
		var halfArenaWidth = arenaWidth / 2;
		var halfArenaHeight = arenaHeight / 2;
		var halfArenaDepth = arenaDepth / 2;
		var rightWall = (arenaWidth / 2) - halfPaddleWidth;
		var leftWall = (-arenaWidth / 2) + halfPaddleWidth;
		var topWall = (arenaHeight / 2) - halfPaddleHeight;
		var bottomWall = (-arenaHeight / 2) + halfPaddleHeight;
		var collisionResult = false;
		var bluePaddleMissed = false;
		var redPaddleMissed = false;
		var redPaddleDesiredDirection = new THREE.Vector3( 0, 0, 0 );
		var redPaddleFixedPosZ = 0;
		var bluePaddleFixedPosZ = 0;
		var mouseControl = false;
		var blueScore = 0;
		var redScore = 0;
		var resetScores = true;
		var blueWins = false;
		var redWins = false;
		var winnerCutScene = false;
		var cameraAngle = 0;
		
		//var skybox = THREEx.createSkymap( 'skybox' )
		 //scene.add( skybox );
		var skyCubeTexture = THREEx.createTextureCube([
			'images/skybox/moondust-xpos.png', 'images/skybox/moondust-xneg.png',
			'images/skybox/moondust-ypos.png', 'images/skybox/moondust-yneg.png',
			'images/skybox/moondust-zpos.png', 'images/skybox/moondust-zneg.png',
		]);
		var skyMesh = THREEx.createSkymap({
			textureCube: skyCubeTexture,
			cubeW: 2000,
			cubeH: 300,
			cubeD: 1000
		});
		scene.add( skyMesh );
		
		var backTriangle = new THREE.Triangle( new THREE.Vector3(-halfArenaWidth, halfArenaHeight, -halfArenaDepth), new THREE.Vector3(-halfArenaWidth, -halfArenaHeight, -halfArenaDepth), new THREE.Vector3(halfArenaWidth, -halfArenaHeight, -halfArenaDepth) );
		var backTriangleNormal = backTriangle.normal();
		var frontTriangle = new THREE.Triangle( new THREE.Vector3(halfArenaWidth, -halfArenaHeight, halfArenaDepth), new THREE.Vector3(-halfArenaWidth, -halfArenaHeight, halfArenaDepth), new THREE.Vector3(-halfArenaWidth, halfArenaHeight, halfArenaDepth) );
		var frontTriangleNormal = frontTriangle.normal();
		var rightTriangle = new THREE.Triangle( new THREE.Vector3(halfArenaWidth, -halfArenaHeight, -halfArenaDepth), new THREE.Vector3(halfArenaWidth, -halfArenaHeight, halfArenaDepth), new THREE.Vector3(halfArenaWidth, halfArenaHeight, halfArenaDepth) );
		var rightTriangleNormal = rightTriangle.normal();
		var leftTriangle = new THREE.Triangle( new THREE.Vector3(-halfArenaWidth, -halfArenaHeight, -halfArenaDepth), new THREE.Vector3(-halfArenaWidth, halfArenaHeight, -halfArenaDepth), new THREE.Vector3(-halfArenaWidth, halfArenaHeight, halfArenaDepth) );
		var leftTriangleNormal = leftTriangle.normal();
		var topTriangle = new THREE.Triangle( new THREE.Vector3(halfArenaWidth, halfArenaHeight, -halfArenaDepth), new THREE.Vector3(halfArenaWidth, halfArenaHeight, halfArenaDepth), new THREE.Vector3(-halfArenaWidth, halfArenaHeight, halfArenaDepth) );
		var topTriangleNormal = topTriangle.normal();
		var bottomTriangle = new THREE.Triangle( new THREE.Vector3(-halfArenaWidth, -halfArenaHeight, -halfArenaDepth), new THREE.Vector3(-halfArenaWidth, -halfArenaHeight, halfArenaDepth), new THREE.Vector3(halfArenaWidth, -halfArenaHeight, halfArenaDepth) );
		var bottomTriangleNormal = bottomTriangle.normal();

		var lineGeometry = new THREE.Geometry();
		var vertArray = lineGeometry.vertices;
		vertArray.push( new THREE.Vector3(-halfArenaWidth, halfArenaHeight, halfArenaDepth), new THREE.Vector3(-halfArenaWidth, -halfArenaHeight, halfArenaDepth),
			new THREE.Vector3(halfArenaWidth, halfArenaHeight, halfArenaDepth), new THREE.Vector3(halfArenaWidth, -halfArenaHeight, halfArenaDepth),
			new THREE.Vector3(-halfArenaWidth, halfArenaHeight, halfArenaDepth), new THREE.Vector3(halfArenaWidth, halfArenaHeight, halfArenaDepth),
			new THREE.Vector3(-halfArenaWidth, -halfArenaHeight, halfArenaDepth), new THREE.Vector3(halfArenaWidth, -halfArenaHeight, halfArenaDepth),

			new THREE.Vector3(-halfArenaWidth, halfArenaHeight, -halfArenaDepth), new THREE.Vector3(-halfArenaWidth, -halfArenaHeight, -halfArenaDepth),
			new THREE.Vector3(halfArenaWidth, halfArenaHeight, -halfArenaDepth), new THREE.Vector3(halfArenaWidth, -halfArenaHeight, -halfArenaDepth),
			new THREE.Vector3(-halfArenaWidth, halfArenaHeight, -halfArenaDepth), new THREE.Vector3(halfArenaWidth, halfArenaHeight, -halfArenaDepth),
			new THREE.Vector3(-halfArenaWidth, -halfArenaHeight, -halfArenaDepth), new THREE.Vector3(halfArenaWidth, -halfArenaHeight, -halfArenaDepth),

			new THREE.Vector3(-halfArenaWidth, -halfArenaHeight, halfArenaDepth), new THREE.Vector3(-halfArenaWidth, -halfArenaHeight, -halfArenaDepth),
			new THREE.Vector3(halfArenaWidth, -halfArenaHeight, halfArenaDepth), new THREE.Vector3(halfArenaWidth, -halfArenaHeight, -halfArenaDepth),
			new THREE.Vector3(-halfArenaWidth, halfArenaHeight, halfArenaDepth), new THREE.Vector3(-halfArenaWidth, halfArenaHeight, -halfArenaDepth),
			new THREE.Vector3(halfArenaWidth, halfArenaHeight, halfArenaDepth), new THREE.Vector3(halfArenaWidth, halfArenaHeight, -halfArenaDepth)
		);
		lineGeometry.computeLineDistances();
		var lineMaterial = new THREE.LineBasicMaterial({
			color: 'rgb(0,255,0)'
		});
		var lineArena = new THREE.Line( lineGeometry, lineMaterial, THREE.LinePieces );
		scene.add( lineArena );
		//lineArena.visible = false;
		
		 //blue paddle
		var boxGeometry = new THREE.BoxGeometry( paddleWidth, paddleHeight, paddleDepth );
		var boxMaterial = new THREE.MeshBasicMaterial();
		var bluePaddle = new THREE.Mesh( boxGeometry, boxMaterial );
		scene.add( bluePaddle );
		bluePaddle.visible = false;
		
		var blueGlow = new THREEx.GeometricGlowMesh( bluePaddle );
		blueGlow.outsideMesh.scale.set( 1.08, 1.08, 1 );
		bluePaddle.add( blueGlow.object3d );
		
		var blueInsideUniforms = blueGlow.insideMesh.material.uniforms;
		var blueOutsideUniforms = blueGlow.outsideMesh.material.uniforms;
		blueInsideUniforms.glowColor.value.set( new THREE.Color( 'rgb(0,0,255)' ) );
		blueOutsideUniforms.glowColor.value.set( new THREE.Color( 'rgb(0,0,50)' ) );
		var blueInsideCoef = 1.2;
		
		//var insideFlag = true;
		blueInsideUniforms.coeficient.value = blueInsideCoef;//range 0 - 2
		blueInsideUniforms.power.value = 0.8;//range 0 - 5
		blueOutsideUniforms.coeficient.value = 1.1;//range 0 - 2
		blueOutsideUniforms.power.value = 0.8;//range 0 - 5

		 //red paddle
		var boxGeometry = new THREE.BoxGeometry( paddleWidth, paddleHeight, paddleDepth );
		var boxMaterial = new THREE.MeshBasicMaterial();
		var redPaddle = new THREE.Mesh( boxGeometry, boxMaterial );
		scene.add( redPaddle );
		redPaddle.visible = false;
		
		var redGlow = new THREEx.GeometricGlowMesh( redPaddle );
		redGlow.outsideMesh.scale.set( 1.08, 1.08, 1 );
		redPaddle.add( redGlow.object3d );
		
		var redInsideUniforms = redGlow.insideMesh.material.uniforms;
		var redOutsideUniforms = redGlow.outsideMesh.material.uniforms;
		redInsideUniforms.glowColor.value.set( new THREE.Color( 'rgb(255,0,0)' ) );
		redOutsideUniforms.glowColor.value.set( new THREE.Color( 'rgb(50,0,0)' ) );
		var redInsideCoef = 1.2;
		
		redInsideUniforms.coeficient.value = redInsideCoef;//range 0 - 2
		redInsideUniforms.power.value = 0.8;//range 0 - 5
		redOutsideUniforms.coeficient.value = 1.1;//range 0 - 2
		redOutsideUniforms.power.value = 0.8;//range 0 - 5
		
		 //ball
		var sphereGeometry = new THREE.SphereGeometry( ballRadius, 10, 10 );
		var sphereMaterial = new THREE.MeshBasicMaterial();
		var ball = new THREE.Mesh( sphereGeometry, sphereMaterial );
		scene.add( ball );
		ball.visible = false;
		
		var ballGlow = new THREEx.GeometricGlowMesh( ball );
		ballGlow.outsideMesh.scale.set( 1.2, 1.2, 1.2 );
		ball.add( ballGlow.object3d );
		
		var ballInsideUniforms = ballGlow.insideMesh.material.uniforms;
		var ballOutsideUniforms = ballGlow.outsideMesh.material.uniforms;
		ballInsideUniforms.glowColor.value.set( new THREE.Color( 'rgb(255,255,255)' ) );
		ballOutsideUniforms.glowColor.value.set( new THREE.Color( 'rgb(35,35,35)' ) );
		var ballInsideCoef = 1.1;

		ballInsideUniforms.coeficient.value = ballInsideCoef;//range 0 - 2
		ballInsideUniforms.power.value = 0.8;//range 0 - 5
		ballOutsideUniforms.coeficient.value = 1.1;//range 0 - 2
		ballOutsideUniforms.power.value = 0.8;//range 0 - 5
		var ballGlowFlag = false;

		 // Circle
		var circleRadius = ballRadius;
		var circleShape = new THREE.Shape();
		circleShape.moveTo( 0, circleRadius );
		circleShape.quadraticCurveTo( circleRadius, circleRadius, circleRadius, 0 );
		circleShape.quadraticCurveTo( circleRadius, -circleRadius, 0, -circleRadius );
		circleShape.quadraticCurveTo( -circleRadius, -circleRadius, -circleRadius, 0 );
		circleShape.quadraticCurveTo( -circleRadius, circleRadius, 0, circleRadius );

		var discGeometry = new THREE.ShapeGeometry( circleShape );
		var discMaterial = new THREE.MeshBasicMaterial({
			color: 'rgb(100,100,100)',
			transparent: true,
			opacity: 0.5 
		});
		var disc1 = new THREE.Mesh( discGeometry, discMaterial );
		scene.add( disc1 );
		var disc2 = new THREE.Mesh( discGeometry, discMaterial );
		scene.add( disc2 );
		var disc3 = new THREE.Mesh( discGeometry, discMaterial );
		scene.add( disc3 );
		var disc4 = new THREE.Mesh( discGeometry, discMaterial );
		scene.add( disc4 );

		updateHUD();

		camera.position.z = 160;

		bluePaddle.position.x = 0.0;
		bluePaddle.position.y = 0.0;
		bluePaddleFixedPosZ = arenaDepth / 2 + paddleDepth;
		bluePaddle.position.z = bluePaddleFixedPosZ;

		redPaddle.position.x = 0.0;
		redPaddle.position.y = 0.0;
		redPaddleFixedPosZ = -arenaDepth / 2 - paddleDepth;
		redPaddle.position.z = redPaddleFixedPosZ;

		disc1.position.set( halfArenaWidth, 0, 0 );
		disc1.rotation.set( 0, Math.PI / -2, 0 );
		disc2.position.set( -halfArenaWidth, 0, 0 );
		disc2.rotation.set( 0, Math.PI / 2, 0 );
		disc3.position.set( 0, halfArenaHeight, 0 );
		disc3.rotation.set( Math.PI / 2, 0, 0 );
		disc4.position.set( 0, -halfArenaHeight, 0 );
		disc4.rotation.set( Math.PI / -2, 0, 0 );
		
		var gravityClicked = false;
		document.getElementById( "gravity" ).onclick = gravityClickHandler;
		document.getElementById( "gravity" ).ontouchend = gravityClickHandler;
		
		var difficultyLevel = 1;
		var redPaddleMaxSpeed = 110;
		document.getElementById( "difficulty" ).onclick = difficultyClickHandler;
		document.getElementById( "difficulty" ).ontouchend = difficultyClickHandler;
		
		var gameSoundsÂ  = new WebAudiox.GameSounds();
		gameSounds.lineOut.volume = 1.0;
		gameSounds.listenerFollow( camera );
		
		var bounceSoundUrl	= 'sounds/mediumPing.mp3';
		var paddleHitSoundUrl	= 'sounds/lowPing.mp3';
		var paddleMissSoundUrl	= 'sounds/paddleMiss.mp3';
		var paddleWinSoundUrl	= 'sounds/winner.mp3';
		var winCutSceneSoundUrl	= 'sounds/synthHit.mp3';
		
		var bounceSound = new WebAudiox.GameSound( gameSounds );
		bounceSound.load( bounceSoundUrl );
		//bounceSound.register('ballSounds');
		var paddleHitSound = new WebAudiox.GameSound( gameSounds );
		paddleHitSound.load( paddleHitSoundUrl );
		//paddleHitSound.register('ballSounds');
		var paddleMissSound = new WebAudiox.GameSound( gameSounds );
		paddleMissSound.load( paddleMissSoundUrl );
		//paddleMissSound.register('ballSounds');
		var paddleWinSound = new WebAudiox.GameSound( gameSounds );
		paddleWinSound.load( paddleWinSoundUrl );
		//paddleWinSound.register('ballSounds');
		var winCutSceneSound = new WebAudiox.GameSound( gameSounds );
		winCutSceneSound.load( winCutSceneSoundUrl );
		//paddleWinSound.register('ballSounds');
		
		animate();


		function animate() {

			requestAnimationFrame( animate );

			frameTime = clock.getDelta();
			
			gameSounds.update( frameTime );
			
			if (winnerCutScene){
			
				cameraAngle += frameTime;
				//cameraAngle += 0.01;
				
				bluePaddle.position.x = 0.0;
				bluePaddle.position.y = 0.0;
				bluePaddle.position.z = bluePaddleFixedPosZ;

				redPaddle.position.x = 0.0;
				redPaddle.position.y = 0.0;
				redPaddle.position.z = redPaddleFixedPosZ;
				
				if(blueWins){
					camera.lookAt( bluePaddle.position );
					camera.position.x = bluePaddle.position.x + Math.sin(cameraAngle) * 50;
					camera.position.z = bluePaddle.position.z + Math.cos(cameraAngle) * 50;
				}	
				if(redWins){
					camera.lookAt( redPaddle.position );
					camera.position.x = redPaddle.position.x + Math.sin(cameraAngle) * 50;
					camera.position.z = redPaddle.position.z + Math.cos(cameraAngle) * 50;
				}
				camera.position.y = -30;
				
				cutSceneTimer.run( frameTime );
				
				if(cutSceneTimer.alarmSounding){
					gameReset = true;
					resetScores = true;
					cutSceneTimer.reset();
					winnerCutScene = false;
				}
				
			}

			if (gameReset) {
				cameraAngle = 0;
				camera.position.set( 0, 0, 160 );
				ball.position.set( 0, 0, 0 );
				
				if(difficultyLevel == 0)
					ballSpeed = 70;
				if(difficultyLevel == 1)
					ballSpeed = 80;
				if(difficultyLevel == 2)
					ballSpeed = 100;
				if(difficultyLevel == 3)
					ballSpeed = 130;
					
				ballDirection.x = 1 - Math.random() * 2;
				ballDirection.y = 1 - Math.random() * 2;
				ballDirection.z = -1.5;
				ballDirection.normalize();

				bluePaddleMissed = false;
				redPaddleMissed = false;
				blueWins = false;
				redWins = false;
				missedTimer.reset();
				if (resetScores) {
					blueScore = 0;
					redScore = 0;
					resetScores = false;
				}
				
				document.getElementById( "bluescore" ).innerHTML = blueScore;
				document.getElementById( "redscore" ).innerHTML = redScore;
				
				document.getElementById( "winner" ).innerHTML = "";
				
				gameReset = false;
				
			}//end if (gameReset)

			if(winnerCutScene == false){
			
				if ( keyboard.pressed("D") ) {
					bluePaddle.position.x += 50 * frameTime;
				}
				if ( keyboard.pressed("A") ) {
					bluePaddle.position.x -= 50 * frameTime;
				}
				if ( keyboard.pressed("W") ) {
					bluePaddle.position.y += 50 * frameTime;
				}
				if ( keyboard.pressed("S") ) {
					bluePaddle.position.y -= 50 * frameTime;
				}

				if ( keyboard.pressed("M") ) {
					mouseControl = true;
				}
			
				if (joystick) {
			
					newDeltaX = joystick.deltaX();
					newDeltaY = joystick.deltaY();

					deltaXDifference = newDeltaX - oldDeltaX;
					deltaYDifference = newDeltaY - oldDeltaY;


					if (mouseControl) joystick._pressed = true;

					if (joystick._pressed) {

						if (firstTouchMove == false) {
							bluePaddle.position.x += ( deltaXDifference / joystickDampening );
							bluePaddle.position.y -= ( deltaYDifference / joystickDampening );
						} else if (firstTouchMove == true) {
							//did the player swipe yet?
							if (Math.abs(deltaXDifference) > 0 || Math.abs(deltaYDifference) > 0) {
								//initial touchmove starts rough, so make sure it is smooth first
								if (Math.abs(deltaXDifference) < 10 && Math.abs(deltaYDifference) < 10)
									firstTouchMove = false; //only a small first movement will trigger this
							}
						}

					} else { //joystick not pressed
						//reset firstTouchMove
						firstTouchMove = true;
					}

					oldDeltaX = newDeltaX;
					oldDeltaY = newDeltaY;

				} //end if(joystick)
			
			}//end if(winnerCutScene == false)
			
			//gravity effect
			if (gravityOn)
				ballDirection.y -= 0.3 * frameTime;

			ball.translateOnAxis( ballDirection, ballSpeed * frameTime );
				
			


			if (bluePaddleMissed == false && redPaddleMissed == false && winnerCutScene == false) {
				
				updateAI();
				//back wall Red Paddle
				if ( (ball.position.z - ballRadius) < redPaddle.position.z ) {
					ball.position.z = redPaddle.position.z + ballRadius;

					collisionResult = checkBallPaddleCollision( ball.position, redPaddle.position );
					if (collisionResult === true) {
						paddleHitSound.play({ volume: 0.1 });
						ballDirection.reflect( backTriangleNormal );
						//allow steering
						ballDirection.x += redPaddleDesiredDirection.x;
						ballDirection.y += redPaddleDesiredDirection.y;
						ballDirection.z += ( Math.abs(redPaddleDesiredDirection.x) + Math.abs(redPaddleDesiredDirection.y) );
						ballDirection.normalize();
						//slightly increase ball speed every volley
						ballSpeed *= 1.03;
						ballGlowFlag = true;
						ballInsideCoef = 2.2;
					} else {
						paddleMissSound.play({ volume: 0.3 });
						handleMiss( redPaddle );
					}
				}
				//front wall Blue Paddle
				if ( (ball.position.z + ballRadius) > bluePaddle.position.z ) {
					ball.position.z = bluePaddle.position.z - ballRadius;

					collisionResult = checkBallPaddleCollision( ball.position, bluePaddle.position );
					if (collisionResult === true) {
						paddleHitSound.play({ volume: 0.5 });
						ballDirection.reflect( frontTriangleNormal );
						//allow steering
						ballDirection.x += deltaXDifference;
						ballDirection.y -= deltaYDifference;
						ballDirection.z -= ( Math.abs(deltaXDifference) + Math.abs(deltaYDifference) );
						ballDirection.normalize();
						//slightly increase ball speed every volley
						ballSpeed *= 1.03;
						ballGlowFlag = true;
						ballInsideCoef = 2.2;
					} else {
						paddleMissSound.play({ volume: 0.4 });
						handleMiss( bluePaddle );
					}
				}
				//left wall
				if ( (ball.position.x - ballRadius) < -halfArenaWidth ) {
					bounceSound.play({ position: ball.position });
					ball.position.x = -halfArenaWidth + ballRadius;
					ballDirection.reflect( leftTriangleNormal );
					ballDirection.normalize();
					ballGlowFlag = true;
					ballInsideCoef = 2.2;
				}
				//right wall
				if ( (ball.position.x + ballRadius) > halfArenaWidth ) {
					bounceSound.play({ position: ball.position });
					ball.position.x = halfArenaWidth - ballRadius;
					ballDirection.reflect( rightTriangleNormal );
					ballDirection.normalize();
					ballGlowFlag = true;
					ballInsideCoef = 2.2;
				}
				//bottom wall
				if ( (ball.position.y - ballRadius) < -halfArenaHeight ) {
					bounceSound.play({ position: ball.position });
					ball.position.y = -halfArenaHeight + ballRadius;
					ballDirection.reflect( bottomTriangleNormal );
					ballDirection.normalize();
					ballGlowFlag = true;
					ballInsideCoef = 2.2;
				}
				//top wall
				if ( (ball.position.y + ballRadius) > halfArenaHeight ) {
					bounceSound.play({ position: ball.position });
					ball.position.y = halfArenaHeight - ballRadius;
					ballDirection.reflect( topTriangleNormal );
					ballDirection.normalize();
					ballGlowFlag = true;
					ballInsideCoef = 2.2;
				}
				
			

				if (ball.position.x > 0) {
					disc1.visible = true;
					disc1.position.set( halfArenaWidth, ball.position.y, ball.position.z );
					disc2.visible = false;
				}
				if (ball.position.x < 0) {
					disc2.visible = true;
					disc2.position.set( -halfArenaWidth, ball.position.y, ball.position.z );
					disc1.visible = false;
				}
				if (ball.position.y > 0) {
					disc3.visible = true;
					disc3.position.set( ball.position.x, halfArenaHeight, ball.position.z );
					disc4.visible = false;
				}
				if (ball.position.y < 0) {
					disc4.visible = true;
					disc4.position.set( ball.position.x, -halfArenaHeight, ball.position.z );
					disc3.visible = false;
				}
						
				
			} //end if (bluePaddleMissed == false && redPaddleMissed == false && winnerCutScene == false)
			
			if (bluePaddleMissed || redPaddleMissed) {

					disc1.visible = false;
					disc2.visible = false;
					disc3.visible = false;
					disc4.visible = false;

					missedTimer.run( frameTime );

					if (missedTimer.alarmSounding){
				
						if(blueWins || redWins){
							paddleWinSound.play({ volume: 0.1 });
							winCutSceneSound.play({ volume: 0.1 });
							camera.position.set(0,100,0);
							bluePaddleMissed = false;
							redPaddleMissed = false;
							winnerCutScene = true;
							
							if(blueWins){
								document.getElementById( "winner" ).style.color = "rgb(0,0,255)";
							}
							if(redWins){	
								document.getElementById( "winner" ).style.color = "rgb(255,0,0)";
							}
							
							document.getElementById( "winner" ).innerHTML = "WINNER!";
						}
						else{
							gameReset = true;
						}
						
					}
					
			}//end if(bluePaddleMissed || redPaddleMissed)
			
			//keep players inside arena
			if (bluePaddle.position.x > rightWall)
				bluePaddle.position.x = rightWall;
			if (bluePaddle.position.x < leftWall)
				bluePaddle.position.x = leftWall;
			if (bluePaddle.position.y > topWall)
				bluePaddle.position.y = topWall;
			if (bluePaddle.position.y < bottomWall)
				bluePaddle.position.y = bottomWall;

			if (redPaddle.position.x > rightWall)
				redPaddle.position.x = rightWall;
			if (redPaddle.position.x < leftWall)
				redPaddle.position.x = leftWall;
			if (redPaddle.position.y > topWall)
				redPaddle.position.y = topWall;
			if (redPaddle.position.y < bottomWall)
				redPaddle.position.y = bottomWall;
				
			/*
			if (insideFlag == false){
				insideCoef -= 1 * frameTime;
				if (insideCoef < 0.2){
					insideCoef = 0.2;
					insideFlag = true;
				}
			}

			if (insideFlag == true){
				insideCoef += 1 * frameTime;
				if (insideCoef > 1.9){
					insideCoef = 1.9;
					insideFlag = false;
				}
			}
			*/
			
			blueInsideCoef = 3 / ( bluePaddle.position.distanceToSquared( ball.position ) * 0.001 );
			if (blueInsideCoef < 1.15) blueInsideCoef = 1.15;
			if (blueInsideCoef > 3) blueInsideCoef = 3;
			blueInsideUniforms.coeficient.value = blueInsideCoef;
			
			redInsideCoef = 3 / ( redPaddle.position.distanceToSquared( ball.position ) * 0.001 );
			if (redInsideCoef < 1.15) redInsideCoef = 1.15;
			if (redInsideCoef > 3) redInsideCoef = 3;
			redInsideUniforms.coeficient.value = redInsideCoef;
			
			if (ballGlowFlag){
				ballInsideCoef -= 4.5 * frameTime;
				if (ballInsideCoef < 1.1){
					ballInsideCoef = 1.1;
					ballGlowFlag = false;
				}
			}
			
			ballInsideUniforms.coeficient.value = ballInsideCoef;
			
			if(winnerCutScene == false)
				camera.lookAt( bluePaddle.position );
			
			renderer.render( scene, camera );


		}//end function animate()

		function updateAI() {
		
			//the following 2 lines provide the simplest AI ever, but, the computer will never lose! :)
			//redPaddle.position.x = ball.position.x;
			//redPaddle.position.y = ball.position.y;

			//the following is not much more complex, but makes it look like the computer is 'trying'
			redPaddleDesiredDirection.subVectors( ball.position, redPaddle.position );
			redPaddleDesiredDirection.normalize();
			redPaddle.translateOnAxis( redPaddleDesiredDirection, redPaddleMaxSpeed * frameTime );
			redPaddle.position.z = redPaddleFixedPosZ; //clamp redPaddle's z position to back wall
			
		}

		function checkBallPaddleCollision( ballPos, paddlePos ) {
		
			if ( ballPos.x > (paddlePos.x - halfPaddleWidth - 4) && 
				ballPos.x < (paddlePos.x + halfPaddleWidth + 4) && 
				ballPos.y > (paddlePos.y - halfPaddleHeight - 4) && 
				ballPos.y < (paddlePos.y + halfPaddleHeight + 4) )
				return true;
			else {
				return false;
			}
			
		}

		function handleMiss( paddle ) {
		
			if (paddle == bluePaddle) {
				bluePaddleMissed = true;
				redScore += 1;
				document.getElementById( "redscore" ).innerHTML = redScore;	
			}
			if (paddle == redPaddle) {
				redPaddleMissed = true;
				blueScore += 1;
				document.getElementById( "bluescore" ).innerHTML = blueScore;
			}
			if (redScore > 4) {
				redWins = true;
				//resetScores = true;
			}
			if (blueScore > 4) {
				blueWins = true;
				//resetScores = true;
			}
			
		}

		function updateHUD() {
			
			var fontAspect = (windowWidth / 200) * (windowHeight / 200);
			if(fontAspect > 20) fontAspect = 20;
			if(fontAspect < 10) fontAspect = 10;
			
			document.getElementById( "gametitle" ).style.fontSize = fontAspect + "px";
			document.getElementById( "gravity" ).style.fontSize = fontAspect + "px";
			document.getElementById( "difficulty" ).style.fontSize = fontAspect + "px";
			
			fontAspect *= 3;
			document.getElementById( "bluescore" ).style.fontSize = fontAspect + "px";
			document.getElementById( "redscore" ).style.fontSize = fontAspect + "px";
			
			document.getElementById( "winner" ).style.fontSize = fontAspect + "px";

		}

		function onWindowResize() {
		
			windowWidth = window.innerWidth;
			windowHeight = window.innerHeight;

			camera.aspect = windowWidth / windowHeight;
			camera.updateProjectionMatrix();

			updateHUD();
			renderer.setSize( windowWidth, windowHeight );
			
		}
		
		function gravityClickHandler(){
		
			gravityClicked = !gravityClicked;
			
			if(gravityClicked){
				document.getElementById( "gravity" ).innerHTML = "Gravity ON";
				document.getElementById( "gravity" ).style.color = "rgb(180,180,180)";
				gravityOn = true;
			}
			if(!gravityClicked){
 				document.getElementById( "gravity" ).innerHTML = "Gravity OFF";
				document.getElementById( "gravity" ).style.color = "rgb(100,100,100)";
				gravityOn = false;
			}
			
		}
		
		function difficultyClickHandler(){
		
			difficultyLevel += 1;
			if(difficultyLevel > 3)
				difficultyLevel = 0;
		
			switch (difficultyLevel){
				case 0:
					document.getElementById( "difficulty" ).innerHTML = "Difficulty: EASY";
					redPaddleMaxSpeed = 70;
					break;
				case 1:
					document.getElementById( "difficulty" ).innerHTML = "Difficulty: MEDIUM";
					redPaddleMaxSpeed = 110;
					break;
				case 2:
					document.getElementById( "difficulty" ).innerHTML = "Difficulty: HARD";
					redPaddleMaxSpeed = 170;
					break;
				case 3:
					document.getElementById( "difficulty" ).innerHTML = "Difficulty: EXPERT";
					redPaddleMaxSpeed = 230;
					break;
				default: 
					document.getElementById( "difficulty" ).innerHTML = "Difficulty: MEDIUM";
					redPaddleMaxSpeed = 110;
			}	
			
		}
	</script>

</body>

</html>
