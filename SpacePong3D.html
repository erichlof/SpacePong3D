<!DOCTYPE html>
<html>

<head>

	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<title>SpacePong3D</title>
</head>

<body>
	<div id="help" style="position:fixed; left:48%; top:4%; color:white;">
		SpacePong3D
	</div>

	<div id="help1" style="position:fixed; left:40%; bottom:8%; color:grey;">
		Desktop: Press 'M' to control paddle with Mouse. Or 'WASD' keys to move paddle
	</div>

	<div id="help2" style="position:fixed; left:40%; bottom:4%; color:grey;">
		Mobile: Hold finger down and slow Swipe to move paddle
	</div>

	<div id="debug1" style="position:fixed; left:5%; top:4%; color:grey;">
		Debug Info
	</div>

	<div id="debug2" style="position:fixed; left:5%; top:8%; color:grey;">
		Debug Info
	</div>

	<div id="debug3" style="position:fixed; left:5%; top:12%; color:grey;">
		Debug Info
	</div>

	<div id="debug4" style="position:fixed; left:5%; top:16%; color:grey;">
		Debug Info
	</div>

	<script src="http://threejs.org/build/three.min.js"></script>
	<script src="js/threex.texturecube.js"></script>
	<script src="js/threex.skymap.js"></script>
	<script src="js/threex.keyboardstate.js"></script>
	<script src="js/virtualjoystick.js"></script>
	<script src="js/threex.GameTimer.js"></script>
	<script>
		var windowWidth = window.innerWidth;
		var windowHeight = window.innerHeight;
		var halfWindowWidth = windowWidth / 2;
		var halfWindowHeight = windowHeight / 2;
		var scene = new THREE.Scene();
		var sceneOrtho = new THREE.Scene();
		var camera = new THREE.PerspectiveCamera(65, windowWidth / windowHeight, 0.1, 2000);
		var cameraOrtho = new THREE.OrthographicCamera( - halfWindowWidth, halfWindowWidth, halfWindowHeight, - halfWindowHeight, 1, 10 );
		cameraOrtho.position.z = 10;
		var clock = new THREE.Clock();
		var missedTimer = new THREEx.GameTimer(3);

		var keyboard = new THREEx.KeyboardState();
		var joystick = new VirtualJoystick({
			mouseSupport: true, // ,
			hideJoystick: true // ,
			//stationaryBase: true,
			//baseX: 400,
			//baseY: 200,
			//limitStickTravel: true,
			//stickRadius: 100
		});

		var renderer = new THREE.WebGLRenderer();
		renderer.setClearColor('rgb(0,0,0)', 1);
		renderer.setSize(windowWidth, windowHeight);
		renderer.autoClear = false; // To allow render overlay on top
		document.body.appendChild(renderer.domElement);
		window.addEventListener('resize', onWindowResize, false);

		var gameReset = true;
		var frameTime = 0;
		var firstTouchMove = true;
		var joystickDampening = 2;
		var deltaXDifference = 0;
		var deltaYDifference = 0;
		var oldDeltaX = 0;
		var oldDeltaY = 0;
		var newDeltaX = 0;
		var newDeltaY = 0;

		var ballSpeed = 0;
		var ballDirection = new THREE.Vector3(0, 0, 0);
		var ballRadius = 3;
		var paddleWidth = 20;
		var paddleHeight = 14;
		var paddleDepth = 4;
		var halfPaddleWidth = paddleWidth / 2;
		var halfPaddleHeight = paddleHeight / 2;
		var arenaWidth = 100; //100
		var arenaHeight = 60; //60
		var arenaDepth = 200; //200
		var halfArenaWidth = arenaWidth / 2;
		var halfArenaHeight = arenaHeight / 2;
		var halfArenaDepth = arenaDepth / 2;
		var rightWall = (arenaWidth / 2) - halfPaddleWidth;
		var leftWall = (-arenaWidth / 2) + halfPaddleWidth;
		var topWall = (arenaHeight / 2) - halfPaddleHeight;
		var bottomWall = (-arenaHeight / 2) + halfPaddleHeight;
		var collisionResult = false;
		var bluePaddleMissed = false;
		var redPaddleMissed = false;
		var redPaddleDesiredDirection = new THREE.Vector3(0, 0, 0);
		var redPaddleMaxSpeed = 150;
		var redPaddlePosZ = 0;
		var mouseControl = false;
          	var blueScore = 0;
          	var redScore = 0;
          	var resetScores = true;
          	var blueWins = false;
          	var redWins = false;
		/*
		var arenaGeometry = new THREE.BoxGeometry(arenaWidth, arenaHeight, arenaDepth);
		var arenaMaterial = new THREE.MeshBasicMaterial({
			color: 'rgb(0,0,0)',
			transparent: true,
			opacity: 0
		});
		var arena = new THREE.Mesh(arenaGeometry, arenaMaterial);
		scene.add(arena);
*/
		var skybox = THREEx.createSkymap('skybox')
		scene.add( skybox );
		var backTriangle = new THREE.Triangle(new THREE.Vector3(-halfArenaWidth, halfArenaHeight, -halfArenaDepth), new THREE.Vector3(-halfArenaWidth, -halfArenaHeight, -halfArenaDepth), new THREE.Vector3(halfArenaWidth, -halfArenaHeight, -halfArenaDepth));
		var backTriangleNormal = backTriangle.normal();
		var frontTriangle = new THREE.Triangle(new THREE.Vector3(halfArenaWidth, -halfArenaHeight, halfArenaDepth), new THREE.Vector3(-halfArenaWidth, -halfArenaHeight, halfArenaDepth), new THREE.Vector3(-halfArenaWidth, halfArenaHeight, halfArenaDepth));
		var frontTriangleNormal = frontTriangle.normal();
		var rightTriangle = new THREE.Triangle(new THREE.Vector3(halfArenaWidth, -halfArenaHeight, -halfArenaDepth), new THREE.Vector3(halfArenaWidth, -halfArenaHeight, halfArenaDepth), new THREE.Vector3(halfArenaWidth, halfArenaHeight, halfArenaDepth));
		var rightTriangleNormal = rightTriangle.normal();
		var leftTriangle = new THREE.Triangle(new THREE.Vector3(-halfArenaWidth, -halfArenaHeight, -halfArenaDepth), new THREE.Vector3(-halfArenaWidth, halfArenaHeight, -halfArenaDepth), new THREE.Vector3(-halfArenaWidth, halfArenaHeight, halfArenaDepth));
		var leftTriangleNormal = leftTriangle.normal();
		var topTriangle = new THREE.Triangle(new THREE.Vector3(halfArenaWidth, halfArenaHeight, -halfArenaDepth), new THREE.Vector3(halfArenaWidth, halfArenaHeight, halfArenaDepth), new THREE.Vector3(-halfArenaWidth, halfArenaHeight, halfArenaDepth));
		var topTriangleNormal = topTriangle.normal();
		var bottomTriangle = new THREE.Triangle(new THREE.Vector3(-halfArenaWidth, -halfArenaHeight, -halfArenaDepth), new THREE.Vector3(-halfArenaWidth, -halfArenaHeight, halfArenaDepth), new THREE.Vector3(halfArenaWidth, -halfArenaHeight, halfArenaDepth));
		var bottomTriangleNormal = bottomTriangle.normal();

		var lineGeometry = new THREE.Geometry();
		var vertArray = lineGeometry.vertices;
		vertArray.push(new THREE.Vector3(-halfArenaWidth, halfArenaHeight, halfArenaDepth), new THREE.Vector3(-halfArenaWidth, -halfArenaHeight, halfArenaDepth),
			new THREE.Vector3(halfArenaWidth, halfArenaHeight, halfArenaDepth), new THREE.Vector3(halfArenaWidth, -halfArenaHeight, halfArenaDepth),
			new THREE.Vector3(-halfArenaWidth, halfArenaHeight, halfArenaDepth), new THREE.Vector3(halfArenaWidth, halfArenaHeight, halfArenaDepth),
			new THREE.Vector3(-halfArenaWidth, -halfArenaHeight, halfArenaDepth), new THREE.Vector3(halfArenaWidth, -halfArenaHeight, halfArenaDepth),

			new THREE.Vector3(-halfArenaWidth, halfArenaHeight, -halfArenaDepth), new THREE.Vector3(-halfArenaWidth, -halfArenaHeight, -halfArenaDepth),
			new THREE.Vector3(halfArenaWidth, halfArenaHeight, -halfArenaDepth), new THREE.Vector3(halfArenaWidth, -halfArenaHeight, -halfArenaDepth),
			new THREE.Vector3(-halfArenaWidth, halfArenaHeight, -halfArenaDepth), new THREE.Vector3(halfArenaWidth, halfArenaHeight, -halfArenaDepth),
			new THREE.Vector3(-halfArenaWidth, -halfArenaHeight, -halfArenaDepth), new THREE.Vector3(halfArenaWidth, -halfArenaHeight, -halfArenaDepth),

			new THREE.Vector3(-halfArenaWidth, -halfArenaHeight, halfArenaDepth), new THREE.Vector3(-halfArenaWidth, -halfArenaHeight, -halfArenaDepth),
			new THREE.Vector3(halfArenaWidth, -halfArenaHeight, halfArenaDepth), new THREE.Vector3(halfArenaWidth, -halfArenaHeight, -halfArenaDepth),
			new THREE.Vector3(-halfArenaWidth, halfArenaHeight, halfArenaDepth), new THREE.Vector3(-halfArenaWidth, halfArenaHeight, -halfArenaDepth),
			new THREE.Vector3(halfArenaWidth, halfArenaHeight, halfArenaDepth), new THREE.Vector3(halfArenaWidth, halfArenaHeight, -halfArenaDepth)
		);
		lineGeometry.computeLineDistances();
		var lineMaterial = new THREE.LineBasicMaterial({
			color: 'rgb(0,255,0)'
		});
		var line = new THREE.Line(lineGeometry, lineMaterial, THREE.LinePieces);
		scene.add(line);

		 //blue paddle
		var boxGeometry = new THREE.BoxGeometry(paddleWidth, paddleHeight, paddleDepth);
		var boxMaterial = new THREE.MeshBasicMaterial({
			color: 'rgb(0,0,255)',
			transparent: true,
			opacity: 0.5
		});
		var bluePaddle = new THREE.Mesh(boxGeometry, boxMaterial);
		scene.add(bluePaddle);

		 //red paddle
		var boxGeometry = new THREE.BoxGeometry(paddleWidth, paddleHeight, paddleDepth);
		var boxMaterial = new THREE.MeshBasicMaterial({
			color: 'rgb(255,0,0)',
			transparent: true,
			opacity: 0.5
		});
		var redPaddle = new THREE.Mesh(boxGeometry, boxMaterial);
		scene.add(redPaddle);

		 //sun light
		var sphereGeometry = new THREE.SphereGeometry(50);
		var sphereMaterial = new THREE.MeshBasicMaterial({
			color: 'rgb(255,255,0)'
		});
		var sunSphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
		scene.add(sunSphere);

		 //ball
		var sphereGeometry = new THREE.SphereGeometry(ballRadius);
		var sphereMaterial = new THREE.MeshBasicMaterial({
			color: 'rgb(255,255,255)',
			transparent: true,
			opacity: 0.7
		});
		var ball = new THREE.Mesh(sphereGeometry, sphereMaterial);
		scene.add(ball);

		 // Circle
		var circleRadius = ballRadius;
		var circleShape = new THREE.Shape();
		circleShape.moveTo(0, circleRadius);
		circleShape.quadraticCurveTo(circleRadius, circleRadius, circleRadius, 0);
		circleShape.quadraticCurveTo(circleRadius, -circleRadius, 0, -circleRadius);
		circleShape.quadraticCurveTo(-circleRadius, -circleRadius, -circleRadius, 0);
		circleShape.quadraticCurveTo(-circleRadius, circleRadius, 0, circleRadius);

		var discGeometry = new THREE.ShapeGeometry(circleShape);
		var discMaterial = new THREE.MeshBasicMaterial({
			color: 'rgb(100,100,100)' // ,
			//transparent: true,
			//opacity: 0.5 //0.4
		});
		var disc1 = new THREE.Mesh(discGeometry, discMaterial);
		scene.add(disc1);
		var disc2 = new THREE.Mesh(discGeometry, discMaterial);
		scene.add(disc2);
		var disc3 = new THREE.Mesh(discGeometry, discMaterial);
		scene.add(disc3);
		var disc4 = new THREE.Mesh(discGeometry, discMaterial);
		scene.add(disc4);


		var light = new THREE.PointLight('rgb(255,255,255)', 1, 0);
		scene.add(light);
		light.position.set(1000, 500, -300);
		sunSphere.position.copy(light.position);
		
		// create a canvas element
		var canvas1Width = 64; 
		var canvas1Height = 64;
		var canvas1 = document.createElement('canvas');
		canvas1.width = canvas1Width; canvas1.height = canvas1Height;
		var context1 = canvas1.getContext('2d');
		context1.font = "bold 60px Arial";
		context1.fillStyle = "rgba(255,0,0,1.0)";
		context1.fillText(redScore.toString(), 0, canvas1Height);
		//context1.fillText("Hello World", 0, canvas1Height);
		// canvas contents will be used for a texture
		var textTexture = new THREE.Texture(canvas1) 
		textTexture.needsUpdate = true;
		var textMaterial = new THREE.SpriteMaterial( { map: textTexture } );
		var sprite = new THREE.Sprite( textMaterial );
		sceneOrtho.add( sprite );
		updateHUDSprites();

		camera.position.z = 160;

		bluePaddle.position.x = 0.0;
		bluePaddle.position.y = 0.0;
		bluePaddle.position.z = arenaDepth / 2 + paddleDepth;

		redPaddle.position.x = 0.0;
		redPaddle.position.y = 0.0;
		redPaddlePosZ = -arenaDepth / 2 - paddleDepth;
		redPaddle.position.z = redPaddlePosZ;


		disc1.position.set(halfArenaWidth, 0, 0);
		disc1.rotation.set(0, Math.PI / -2, 0);
		disc2.position.set(-halfArenaWidth, 0, 0);
		disc2.rotation.set(0, Math.PI / 2, 0);
		disc3.position.set(0, halfArenaHeight, 0);
		disc3.rotation.set(Math.PI / 2, 0, 0);
		disc4.position.set(0, -halfArenaHeight, 0);
		disc4.rotation.set(Math.PI / -2, 0, 0);

		var debugText1 = document.getElementById("debug1");
		var debugText2 = document.getElementById("debug2");
		var debugText3 = document.getElementById("debug3");
		var debugText4 = document.getElementById("debug4");

		animate();


		function animate() {

			requestAnimationFrame(animate);

			frameTime = clock.getDelta();
			
			if (gameReset) {
				ball.position.x = 0;
				ball.position.y = 0;
				ball.position.z = 0;

				ballSpeed = 60;
				ballDirection.x = 0.5;
				ballDirection.y = 0.5;
				ballDirection.z = -1;
				ballDirection.normalize();

				bluePaddleMissed = false;
				redPaddleMissed = false;
                          	blueWins = false;
                          	redWins = false;
				missedTimer.reset();
				if (resetScores){
                                	blueScore = 0;
                                  	redScore = 0;
                                  	resetScores = false;
                                }
				
				context1.clearRect(0,0,canvas1Width, canvas1Height);
				context1.fillText(redScore.toString(), 0, canvas1Height);
				textTexture.needsUpdate = true;
				
				gameReset = false;
			}

			if (keyboard.pressed("D")) {
				bluePaddle.position.x += 50 * frameTime;
			}
			if (keyboard.pressed("A")) {
				bluePaddle.position.x -= 50 * frameTime;
			}
			if (keyboard.pressed("W")) {
				bluePaddle.position.y += 50 * frameTime;
			}
			if (keyboard.pressed("S")) {
				bluePaddle.position.y -= 50 * frameTime;
			}
			//for debug
			if(keyboard.pressed("M")){
				mouseControl = true;
			}
			  

			if (joystick) {
				newDeltaX = joystick.deltaX();
				newDeltaY = joystick.deltaY();

				deltaXDifference = newDeltaX - oldDeltaX;
				deltaYDifference = newDeltaY - oldDeltaY;
				
				
				if(mouseControl)joystick._pressed = true;
				
				if (joystick._pressed) {

					if (firstTouchMove == false) {
						bluePaddle.position.x += (deltaXDifference / joystickDampening);
						bluePaddle.position.y -= (deltaYDifference / joystickDampening);
					} else if (firstTouchMove == true) {
						//did the player swipe yet?
						if (Math.abs(deltaXDifference) > 0 || Math.abs(deltaYDifference) > 0) {
							//initial touchmove starts rough, so make sure it is smooth first
							if (Math.abs(deltaXDifference) < 10 && Math.abs(deltaYDifference) < 10)
								firstTouchMove = false; //only a small first movement will trigger this
						}
					}

				} else { //joystick not pressed
					//reset firstTouchMove
					firstTouchMove = true;
				}

				oldDeltaX = newDeltaX;
				oldDeltaY = newDeltaY;


			} //end if(joystick)
			
			ball.translateOnAxis(ballDirection, ballSpeed * frameTime);
			
			if(bluePaddleMissed == false && redPaddleMissed == false)
				updateAI();
			
			//keep players inside arena
			if (bluePaddle.position.x > rightWall)
				bluePaddle.position.x = rightWall;
			if (bluePaddle.position.x < leftWall)
				bluePaddle.position.x = leftWall;
			if (bluePaddle.position.y > topWall)
				bluePaddle.position.y = topWall;
			if (bluePaddle.position.y < bottomWall)
				bluePaddle.position.y = bottomWall;
				
			if (redPaddle.position.x > rightWall)
				redPaddle.position.x = rightWall;
			if (redPaddle.position.x < leftWall)
				redPaddle.position.x = leftWall;
			if (redPaddle.position.y > topWall)
				redPaddle.position.y = topWall;
			if (redPaddle.position.y < bottomWall)
				redPaddle.position.y = bottomWall;



			

			if (bluePaddleMissed == false && redPaddleMissed == false) {
				//back wall Red Paddle
				if ((ball.position.z - ballRadius) < redPaddle.position.z) {
					ball.position.z = redPaddle.position.z + ballRadius;
					
					collisionResult = checkBallPaddleCollision(ball.position, redPaddle.position);
					if (collisionResult === true) {
						ballDirection.reflect(backTriangleNormal);
						ballDirection.normalize();
						ballSpeed *= 1.02;
					} else {
						handleMiss(redPaddle);
					}
				}
				//front wall Blue Paddle
				if ((ball.position.z + ballRadius) > bluePaddle.position.z) {
					ball.position.z = bluePaddle.position.z - ballRadius;

					collisionResult = checkBallPaddleCollision(ball.position, bluePaddle.position);
					if (collisionResult === true) {
						ballDirection.reflect(frontTriangleNormal);
						ballDirection.normalize();
						ballSpeed *= 1.02;
					} else {
						handleMiss(bluePaddle);
					}
				}
				//left wall
				if ((ball.position.x - ballRadius) < -halfArenaWidth) {
					ball.position.x = -halfArenaWidth + ballRadius;
					ballDirection.reflect(leftTriangleNormal);
					ballDirection.normalize();
				}
				//right wall
				if ((ball.position.x + ballRadius) > halfArenaWidth) {
					ball.position.x = halfArenaWidth - ballRadius;
					ballDirection.reflect(rightTriangleNormal);
					ballDirection.normalize();
				}
				//bottom wall
				if ((ball.position.y - ballRadius) < -halfArenaHeight) {
					ball.position.y = -halfArenaHeight + ballRadius;
					ballDirection.reflect(bottomTriangleNormal);
					ballDirection.normalize();
				}
				//top wall
				if ((ball.position.y + ballRadius) > halfArenaHeight) {
					ball.position.y = halfArenaHeight - ballRadius;
					ballDirection.reflect(topTriangleNormal);
					ballDirection.normalize();
				}
			} //end if bluePaddleMissed == false && redPaddleMissed == false

			if (ball.position.x > 0) {
				disc1.position.set(halfArenaWidth, ball.position.y, ball.position.z);
				disc2.position.set(1000, 1000, 1000);
			}
			if (ball.position.x < 0) {
				disc2.position.set(-halfArenaWidth, ball.position.y, ball.position.z);
				disc1.position.set(1000, 1000, 1000);
			}
			if (ball.position.y > 0) {
				disc3.position.set(ball.position.x, halfArenaHeight, ball.position.z);
				disc4.position.set(1000, 1000, 1000);
			}
			if (ball.position.y < 0) {
				disc4.position.set(ball.position.x, -halfArenaHeight, ball.position.z);
				disc3.position.set(1000, 1000, 1000);
			}
			if(bluePaddleMissed || redPaddleMissed){
				disc1.position.set(1000, 1000, 1000);
				disc2.position.set(1000, 1000, 1000);
				disc3.position.set(1000, 1000, 1000);
				disc4.position.set(1000, 1000, 1000);
				
				missedTimer.run(frameTime);
				
				if(missedTimer.alarmSounding)
					gameReset = true;
			}

			camera.lookAt(bluePaddle.position);
			
			
			renderer.clear();
			renderer.render(scene, camera);
			renderer.clearDepth();
			renderer.render( sceneOrtho, cameraOrtho );

			//debugText1.innerHTML = "Ball Dir X: " + ballDirection.x.toFixed(1) +
			//"Ball Dir Y: " + ballDirection.y.toFixed(1) +
			//"Ball Dir Z: " + ballDirection.z.toFixed(1);
			
			//debugText1.innerHTML = "redScore: " + redScore;
			//debugText2.innerHTML = "blueScore: " + blueScore;
			debugText3.innerHTML = "redWins: " + redWins;
			debugText4.innerHTML = "blueWins: " + blueWins;

		}
		
		function updateAI () {
			//the following 2 lines provide the simplest AI ever, but, the computer will never lose! :)
			//redPaddle.position.x = ball.position.x;
			//redPaddle.position.y = ball.position.y;
			
			//the following is not much more complex, but makes it look like the computer is 'trying'
			redPaddleDesiredDirection.subVectors(ball.position, redPaddle.position);
			redPaddleDesiredDirection.normalize();
			redPaddle.translateOnAxis(redPaddleDesiredDirection, redPaddleMaxSpeed * frameTime);
			redPaddle.position.z = redPaddlePosZ;//clamp redPaddle's z position to back wall
		}
		
		function checkBallPaddleCollision(ballPos, paddlePos) {
			if (ballPos.x > paddlePos.x - halfPaddleWidth && ballPos.x < paddlePos.x + halfPaddleWidth && ballPos.y > paddlePos.y - halfPaddleHeight && ballPos.y < paddlePos.y + halfPaddleHeight)
				return true;
			else {
				return false;
			}
		}

		function handleMiss(paddle) {
			if(paddle == bluePaddle){
				bluePaddleMissed = true;
                          	redScore += 1;
				context1.clearRect(0,0,canvas1Width, canvas1Height);
				context1.fillText(redScore.toString(), 0, canvas1Height);
				textTexture.needsUpdate = true;
				//updateHUDSprites();
			}
			if(paddle == redPaddle){
				redPaddleMissed = true;
                          	blueScore += 1;
			}
                  	
                  	if(redScore > 4){
                        	redWins = true;
                          	resetScores =true;
                        }
                  	if(blueScore > 4){
                        	blueWins = true;
                          	resetScores = true;
                        }
		}
		
		function updateHUDSprites(){
		
			//var material = sprite.material;
			var imageWidth = canvas1Width;
			var imageHeight = canvas1Height;
			var halfImageWidth = imageWidth / 2;
			var halfImageHeight = imageHeight / 2;

			sprite.scale.set( halfWindowWidth * halfImageWidth / 200 , halfWindowHeight * halfImageHeight / 150 , 1 );
			//sprite.position.set( - halfWindowWidth + halfImageWidth,   halfWindowHeight - halfImageHeight, 1 ); // top left
			sprite.position.set(  halfWindowWidth - halfImageWidth,   halfWindowHeight - halfImageHeight, 1 ); // top right
			//sprite.position.set( - halfWindowWidth + halfImageWidth, - halfWindowHeight + halfImageHeight, 1 ); // bottom left
			//sprite.position.set(   halfWindowWidth - halfImageWidth, - halfWindowHeight + halfImageHeight, 1 ); // bottom right
			
		}

		function onWindowResize() {
		 	windowWidth = window.innerWidth;
			windowHeight = window.innerHeight;
			halfWindowWidth = windowWidth / 2;
			halfWindowHeight = windowHeight / 2;
			
			camera.aspect = windowWidth / windowHeight;
			camera.updateProjectionMatrix();
			
			cameraOrtho.left = - halfWindowWidth;
			cameraOrtho.right = halfWindowWidth;
			cameraOrtho.top = halfWindowHeight;
			cameraOrtho.bottom = - halfWindowHeight;
			cameraOrtho.updateProjectionMatrix();
			
			updateHUDSprites();
			renderer.setSize(windowWidth, windowHeight);
		}
	</script>

</body>

</html>
